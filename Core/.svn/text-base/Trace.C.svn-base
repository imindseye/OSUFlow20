//------------------------------------------------------------------------------
//
// trace class
// seeds and traces particles
//
// Tom Peterka
// Argonne National Laboratory
// 9700 S. Cass Ave.
// Argonne, IL 60439
// tpeterka@mcs.anl.gov
//
// All rights reserved. May not be used, modified, or copied
// without permission
//
//--------------------------------------------------------------------------

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h> 
#include <list>
#include <iterator>
#include "OSUFlow.h"
#include "Lattice4D.h"
#include "LatticeAMR.h"
#include "Trace.h"

//-----------------------------------------------------------------------
//
Trace::Trace(Lattice4D *lat, OSUFlow **osuflow, VECTOR4 **Seeds, 
	     int *NumSeeds, list<vtListTimeSeedTrace*> *sl_list, VECTOR4 **pt, 
	     int **npt, int *tot_ntrace, int nb, int track_seed_id) {

  lat4D = lat;
  latAMR = NULL;
  this->osuflow = osuflow;
  this->Seeds = Seeds;
  this->NumSeeds = NumSeeds;
  this->sl_list = sl_list;
  this->pt = pt;
  this->npt = npt;
  this->tot_ntrace = tot_ntrace;
  this->track_seed_id = track_seed_id;
  this->nb = nb;

  TotSeeds = 0;
  TotSteps = 0;

  // performance stats
  n_block_stats = 5;
  n_time_stats = 4;
  assert((block_stats = (int *)malloc(n_block_stats * 
				      sizeof(int))) != NULL);
  assert((time_stats = (double *)malloc(n_time_stats * 
					sizeof(double))) != NULL);

}
//----------------------------------------------------------------------------
//
Trace::Trace(LatticeAMR *lat, OSUFlow **osuflow, VECTOR4 **Seeds,
	     int *NumSeeds, list<vtListTimeSeedTrace*> *sl_list, VECTOR4 **pt, 
	     int **npt, int *tot_ntrace, int nb, int track_seed_id) {

  latAMR = lat;
  lat4D = NULL;
  this->osuflow = osuflow;
  this->Seeds = Seeds;
  this->NumSeeds = NumSeeds;
  this->sl_list = sl_list;
  this->pt = pt;
  this->npt = npt;
  this->tot_ntrace = tot_ntrace;
  this->track_seed_id = track_seed_id;
  this->nb = nb;

  TotSeeds = 0;
  TotSteps = 0;

  // performance stats
  n_block_stats = 5;
  n_time_stats = 6;
  assert((block_stats = (int *)malloc(n_block_stats * 
				      sizeof(int))) != NULL);
  assert((time_stats = (double *)malloc(n_time_stats * 
					sizeof(double))) != NULL);

}
//----------------------------------------------------------------------------
//
void Trace::UpdateOSUFlow(OSUFlow **osuflow) {

  this->osuflow = osuflow;
}
//-----------------------------------------------------------------------
//
Trace::Trace(Lattice4D *lat) {

  lat4D = lat;
  latAMR = NULL;
  block_stats = NULL;
  time_stats = NULL;
}
//-----------------------------------------------------------------------
//
Trace::Trace(LatticeAMR *lat) {

  latAMR = lat;
  lat4D = NULL;
  block_stats = NULL;
  time_stats = NULL;
}
//-----------------------------------------------------------------------
//
// destructor
//
Trace::~Trace() {
  if (block_stats != NULL) {
    free(block_stats);
  }
  if (time_stats != NULL) {
    free(time_stats);
  }
}
//-----------------------------------------------------------------------
//
// initializes traces and seeds them
//
// can randomly seed blocks or set specific seeds to blocks
//
void Trace::InitTraces4D(VECTOR4 **Seeds, int *NumSeeds, int *SizeSeeds, 
			 VECTOR3 *seeds, int tf, VECTOR3* specific_seeds,
			 int num_specific_seeds, int64_t **SeedIds) {

  int i, j;
  float from[3], to[3]; // block spatial extent
  int min_t, max_t; // block temporal extent
  int ntpart; // number of time partitions
  int tsize; // number of time steps

  assert(lat4D != NULL);
  tsize = lat4D->ldim;
  ntpart = lat4D->tdim;

  // init all blocks
  for (i = 0; i < lat4D->nb; i++) {

    NumSeeds[i] = 0;
    lat4D->ClearLoad(i);
    lat4D->GetTB(i, &min_t, &max_t);

    // init seeds for blocks in first time group
    if (tsize == 1 || ntpart == 1 || min_t == 0) {

      lat4D->GetVB(i, from, to, &min_t, &max_t);
      if(num_specific_seeds > 0)
	SetSeeds(osuflow[i], from, to, specific_seeds, num_specific_seeds);
      else
	osuflow[i]->SetRandomSeedPoints(from, to, tf); 
      seeds = osuflow[i]->GetSeeds(NumSeeds[i]); 

      while (SizeSeeds[i] < NumSeeds[i] * (int)(sizeof(VECTOR4))) {
	Seeds[i] = (VECTOR4 *)realloc(Seeds[i], SizeSeeds[i] * 2);
	assert(Seeds[i] != NULL);

	if (track_seed_id) {
	  SeedIds[i] = (int64_t *)realloc(SeedIds[i], SizeSeeds[i] * 2);
	  assert(SeedIds[i] != NULL);
	}

	SizeSeeds[i] *= 2;
      }

      for (j = 0; j < NumSeeds[i]; j++)
	Seeds[i][j].Set(seeds[j][0], seeds[j][1], seeds[j][2], min_t);
    }

  }

  if (track_seed_id) {

    int64_t my_num_seeds = 0;
    for (i = 0; i < lat4D->nb; i++) 
      my_num_seeds += NumSeeds[i];
    int64_t my_seed_id_start = 0;

#ifdef _MPI
    MPI_Scan(&my_num_seeds, &my_seed_id_start, 1, MPI_LONG_LONG, MPI_SUM,
	       MPI_COMM_WORLD);
    my_seed_id_start -= my_num_seeds;
#endif

    int64_t seed_id = my_seed_id_start;
    for (i = 0; i < lat4D->nb; i++) 
      for (j = 0; j < NumSeeds[i]; j++, seed_id++)
	SeedIds[i][j] = seed_id;

  }

}
//-----------------------------------------------------------------------
//
// SetSeeds
//
// given a list of specific seeds to use, find the subset that is inside a
// given block, and set those seeds as the seeds for that block
//
//
void Trace::SetSeeds(OSUFlow* osuflow, float* from, float* to, 
		     VECTOR3* specific_seeds, int num_specific_seeds)
{
  // first find the indices of the seeds which are in this block, then copy
  // those seeds over
  std::vector<int> indices;
  float x, y, z;
  for(int i=0; i<num_specific_seeds; i++)
  {
    x = specific_seeds[i][0];
    y = specific_seeds[i][1];
    z = specific_seeds[i][2];
    if(x >= from[0] && x <= to[0] &&
       y >= from[1] && y <= to[1] &&
       z >= from[2] && z <= to[2])
    {
      indices.push_back(i);
    }
  }

  int num_seeds = indices.size();
  VECTOR3* block_seeds = new VECTOR3[num_seeds];
  for(int i=0; i<num_seeds; i++)
  {
    int j = indices[i];
    x = specific_seeds[j][0];
    y = specific_seeds[j][1];
    z = specific_seeds[j][2];
    block_seeds[i].Set(x, y, z);
  }

  osuflow->SetSeedPoints(block_seeds, num_seeds);
  delete [] block_seeds;
}
//-----------------------------------------------------------------------
//
// initializes traces and seeds them
//
void Trace::InitTracesAMR(VECTOR4 **Seeds, int *NumSeeds, int *SizeSeeds, 
			  VECTOR3 *seeds, int tf, int64_t **SeedIds) {

  int i, j;
  float from[3], to[3]; // block spatial extent
  int min_t, max_t; // block temporal extent

  assert(latAMR != NULL);

  // init all blocks
  for (i = 0; i < latAMR->nb; i++) {

    NumSeeds[i] = 0;
    latAMR->ClearLoad(i);
    latAMR->GetTB(i, &min_t, &max_t);

    // init seeds for blocks in first time group
    if (latAMR->tdim == 1 || latAMR->ntpart == 1 || min_t == 0) {

      latAMR->GetVB(i, from, to, &min_t, &max_t);
      osuflow[i]->SetRandomSeedPoints(from, to, tf); 
      seeds = osuflow[i]->GetSeeds(NumSeeds[i]); 

      while (SizeSeeds[i] < NumSeeds[i] * (int)(sizeof(VECTOR4))) {
	Seeds[i] = (VECTOR4 *)realloc(Seeds[i], SizeSeeds[i] * 2);
	assert(Seeds[i] != NULL);
	SizeSeeds[i] *= 2;
      }

      for (j = 0; j < NumSeeds[i]; j++)
	Seeds[i][j].Set(seeds[j][0], seeds[j][1], seeds[j][2], min_t);

    }

  }

}
//-----------------------------------------------------------------------
//
// computes streamlines
//
// block_num: local block number (0 to nblocks-1)
// not global partition number
// pf: point factor (points per trace)
// w: weight of this block (output) (optional)
//
void Trace::ComputeStreamlines(int block_num, int pf, int *w) {

  list<vtListSeedTrace*> list3; // 3D list of traces
  std::list<VECTOR3*>::iterator pt_iter3; // 3D iterator over pts in one trace
  std::list<vtListSeedTrace*>::iterator trace_iter3; // 3D iter. over traces
  VECTOR3 *Seeds3; // 3D seeds in current block
  VECTOR3 p3; // 3D current point
  VECTOR4 *p = NULL; // 4D current point
  vtListTimeSeedTrace *trace; // 4D single trace
  int i;

#ifdef _MPI
  comp_time = MPI_Wtime();
#endif

#ifdef TRACK_SEED_ID
  std::list<int64_t> seed_id_list; // list of seed_ids
  std::list<int64_t>::iterator seed_id_iter; // iter. over seed ids
#endif

  if (NumSeeds[block_num]) {

    TotSeeds += NumSeeds[block_num];

    // make VECTOR3s (temporary)
    assert((Seeds3 = (VECTOR3 *)malloc(NumSeeds[block_num] * sizeof(VECTOR3)))
	   != NULL);
    for (i = 0; i < NumSeeds[block_num]; i++) {
      Seeds3[i][0]= Seeds[block_num][i][0];
      Seeds3[i][1]= Seeds[block_num][i][1];
      Seeds3[i][2]= Seeds[block_num][i][2];
    }
	  
    // perform the integration
    // todo: integrate in both directions
    osuflow[block_num]->SetIntegrationParams(1, 5);
#ifdef TRACK_SEED_ID
    osuflow[block_num]->GenStreamLines(Seeds3, FORWARD_DIR, 
				       NumSeeds[block_num], pf, list3, SeedIds[block_num], &seed_id_list); 
    seed_id_iter = seed_id_list.begin();
#else
    osuflow[block_num]->GenStreamLines(Seeds3, FORWARD_DIR, 
				       NumSeeds[block_num], pf, list3); 
#endif

    // copy each 3D trace to a 4D trace and then to the streamline list
    // post end point of each trace to the send list
    for (trace_iter3 = list3.begin(); trace_iter3 != list3.end(); trace_iter3++
#ifdef TRACK_SEED_ID
	   , seed_id_iter++
#endif
	 ) {

      TotSteps += (*trace_iter3)->size();
      if (w != NULL)
	*w += (*trace_iter3)->size(); // number of steps accrues to block weight
      if (!(*trace_iter3)->size())
	continue;

      trace = new vtListTimeSeedTrace;
      for (pt_iter3 = (*trace_iter3)->begin(); pt_iter3 != 
	     (*trace_iter3)->end(); pt_iter3++) {
	p3 = **pt_iter3;
	p = new VECTOR4;
	p->Set(p3[0], p3[1], p3[2], 0.0f);
	trace->push_back(p);

      }

      // copy VEC4 to float
      float fp[4] = { (*p)[0], (*p)[1], (*p)[2], (*p)[3] };

#ifdef TRACK_SEED_ID
      if (lat4D != NULL)
	lat4D->PostPoint(block_num, fp, 0, *seed_id_iter);
      else
	latAMR->PostPoint(block_num, fp, 0, *seed_id_iter);
      sl_id_list[block_num].push_back(*seed_id_iter); 
#else
      if (lat4D != NULL)
	lat4D->PostPoint(block_num, fp, 0); // last point only
      else
	latAMR->PostPoint(block_num, fp, 0); // last point only
#endif
      sl_list[block_num].push_back(trace); // for later rendering

    }

  }
  
#ifdef _MPI
  comp_time = MPI_Wtime() - comp_time;
#endif

}
//-----------------------------------------------------------------------
//
// computes pathlines
//
// block_num: local block number (0 to nblocks-1)
// not global partition number
// pf: point factor (points per trace)
// w: weight of this block (output) (optional)
//
void Trace::ComputePathlines(int block_num, int pf, int *w) {
  list<vtListTimeSeedTrace*> list; // list of traces
  std::list<VECTOR4*>::iterator pt_iter; // iterator over pts in one trace
  std::list<vtListTimeSeedTrace*>::iterator trace_iter; // iter. over traces
  VECTOR4 p; // current point
  int loaded; // whether a block is loaded
  int i;

#ifdef _MPI
  comp_time = MPI_Wtime();
#endif

#ifdef TRACK_SEED_ID
  std::list<int64_t> seed_id_list; // list of seed_ids
  std::list<int64_t>::iterator seed_id_iter; // iter. over seed ids
#endif

  if (lat4D != NULL)
    loaded = lat4D->GetLoad(block_num);
  else
    loaded = latAMR->GetLoad(block_num);

  if (loaded && NumSeeds[block_num]) {

    TotSeeds += NumSeeds[block_num];

    // perform the integration
    // todo: integrate in both directions
    osuflow[block_num]->SetIntegrationParams(1, 5); 

#ifdef TRACK_SEED_ID
    osuflow[block_num]->GenPathLines(Seeds[block_num], list, FORWARD, 
				     NumSeeds[block_num], pf, SeedIds[block_num], &seed_id_list); 
    seed_id_iter = seed_id_list.begin();
#else
    osuflow[block_num]->GenPathLines(Seeds[block_num], list, FORWARD, 
				     NumSeeds[block_num], pf); 
#endif

    // copy each trace to the streamline list for later rendering
    // post end point of each trace to the send list
    for (trace_iter = list.begin(); trace_iter != list.end(); trace_iter++
#ifdef TRACK_SEED_ID
	   ,seed_id_iter++
#endif
	 ) {

      TotSteps += (*trace_iter)->size();
      if (w != NULL)
	*w += (*trace_iter)->size(); // number of steps accrues to block weight
      if (!(*trace_iter)->size())
	continue;

      // get the end point
      pt_iter = (*trace_iter)->end();
      pt_iter--;
      p = **pt_iter;
      VECTOR4 sp = **((*trace_iter)->begin());

      // copy VEC4 to float
      float fp[4] = { p[0], p[1], p[2], p[3] };

#ifdef TRACK_SEED_ID
      if (lat4D != NULL)
	lat4D->PostPoint(block_num, fp, 0, *seed_id_iter);
      else
	latAMR->PostPoint(block_num, fp, 0, *seed_id_iter);
      sl_id_list[block_num].push_back(*seed_id_iter);
#else
      if (lat4D != NULL)
	lat4D->PostPoint(block_num, fp, 0);
      else
	latAMR->PostPoint(block_num, fp, 0);
#endif
      sl_list[block_num].push_back(*trace_iter); // for later rendering

    }

  }

  // recirculate seeds to myself if the block is not laoded yet
  if (!loaded) {

    for (i = 0; i < NumSeeds[block_num]; i++) {

      // copy VEC4 to float
      float fp[4] = { Seeds[block_num][i][0], Seeds[block_num][i][1], 
		      Seeds[block_num][i][2], Seeds[block_num][i][3] };

#ifdef TRACK_SEED_ID
      if (lat4D != NULL)
	lat4D->PostPoint(block_num, fp, 1, SeedIds[block_num][i]);  
      else
	latAMR->PostPoint(block_num, fp, 1, SeedIds[block_num][i]);  
#else      
      if (lat4D != NULL)
	lat4D->PostPoint(block_num, fp, 1);  
      else
	latAMR->PostPoint(block_num, fp, 1);  
#endif		
    }
  }

#ifdef _MPI
  comp_time = MPI_Wtime() - comp_time;
#endif

}
//-----------------------------------------------------------------------
//
// gathers all fieldlines at the root for rendering
//
void Trace::GatherFieldlines() {

  static int *ntrace = NULL; // number of traces for each proc
  int n; // total number of my points

#ifdef GRAPHICS

  // gather number of points in each trace at the root
  n = GatherNumPts(ntrace, 0);
  
  // gather the actual points in each trace at the root
  GatherPts(ntrace, n);

  // write a file too
  WriteFieldlines(ntrace, n, (char *)"field_lines.out");

#else

#ifdef TRACK_SEED_ID
  DistributedWriteFieldlines((char *)"field_lines.out",
			     (char *)"field_line_ids.out");
#else
  // gather number of points in each trace to everyone
  n = GatherNumPts(ntrace, 1);
  
  // write the traces collectively
  WriteFieldlines(ntrace, n, (char *)"field_lines.out");
#endif

#endif

}
//-----------------------------------------------------------------------
//
// gathers all fieldlines for rendering, serial version
//
void Trace::SerialGatherFieldlines() {

  std::list<vtListTimeSeedTrace *>::iterator trace_iter; // iterator over traces
  std::list<VECTOR4 *>::iterator pt_iter; // iterator over points in one trace
  int nblocks; // number of blocks for this process
  int i, j, k;
  int tot_npts = 0;

  if (lat4D != NULL)
    nblocks = lat4D->nb;
  else
    nblocks = latAMR->nb;

  // compute number of traces and points
  for (i = 0; i < nblocks; i++) {
    *tot_ntrace += sl_list[i].size();
    for (trace_iter = sl_list[i].begin(); trace_iter != sl_list[i].end(); 
         trace_iter++)
      tot_npts += (*trace_iter)->size();
  }

  // allocate rendering data
  assert((*npt = new int[*tot_ntrace]) != NULL);
  assert((*pt = new VECTOR4[tot_npts]) != NULL); // points in everyones traces

  // compute number of points in each trace and collect the points
  j = 0;
  k = 0;
  for (i = 0; i < nblocks; i++) {
    for (trace_iter = sl_list[i].begin(); trace_iter != sl_list[i].end(); 
         trace_iter++) {
      for (pt_iter = (*trace_iter)->begin(); pt_iter != (*trace_iter)->end(); 
         pt_iter++)
	(*pt)[k++] = **pt_iter;
      (*npt)[j++] = (*trace_iter)->size();
    }
  }

}
//-----------------------------------------------------------------------
//
// gathers number of points in each trace to the root
//
// ntrace: number of traces in each process (passed by reference)
// all: all = 0 gather to root, all = 1 gather to all
//
// returns: total number of points in my process
//
int Trace::GatherNumPts(int* &ntrace, int all) {

  int myntrace = 0; // my number of traces
  static int *ofst = NULL; // offsets into ntrace
  int *mynpt; // number of points in each of my traces
  int tot_mynpt = 0; // total number of my points
  int rank, nproc; // MPI usual
  std::list<vtListTimeSeedTrace *>::iterator trace_iter; // iterator over traces
  int nblocks; // number of blocks for this process
  int i, j;

  if (lat4D != NULL)
    nblocks = lat4D->nb;
  else
    nblocks = latAMR->nb;

  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &nproc);

  // allocate memory
  if (ntrace == NULL)
    assert((ntrace = new int[nproc]) != NULL);
  if (ofst == NULL)
    assert((ofst = new int[nproc]) != NULL);

  // compute number of my traces
  for (i = 0; i < nblocks; i++)
    myntrace += sl_list[i].size();

  // gather number of traces
  MPI_Allgather(&myntrace, 1, MPI_INT, ntrace, 1, MPI_INT, MPI_COMM_WORLD);

  // compute number of points in each of my traces
  assert((mynpt = new int[myntrace]) != NULL);
  j = 0;
  for (i = 0; i < nblocks; i++) {
    for (trace_iter = sl_list[i].begin(); trace_iter != sl_list[i].end(); 
         trace_iter++) {
      assert(j < myntrace); // sanity
      mynpt[j] = (*trace_iter)->size();
      tot_mynpt += mynpt[j++];
    }
  }

  // gather number of points in each trace
  *tot_ntrace = 0;
  for (i = 0; i < nproc; i++) {
    ofst[i] = (i == 0) ? 0 : ofst[i - 1] + ntrace[i - 1];
    *tot_ntrace += ntrace[i];
  }
  assert((*npt = new int[*tot_ntrace]) != NULL);
  MPI_Allgatherv(mynpt, myntrace, MPI_INT, *npt, ntrace, ofst, MPI_INT,
		 MPI_COMM_WORLD);

  delete[] mynpt;

  return tot_mynpt;

}
//-----------------------------------------------------------------------
//
// gathers the points in each trace at the root
//
// ntrace: number of traces in each process
// mynpt: total number of points in my process
//
void Trace::GatherPts(int *ntrace, int mynpt) {
  
  static int *nflt = NULL; // number of floats in points from each proc
  static int *ofst = NULL; // offsets into pt
  VECTOR4 *mypt; // points in my traces
  std::list<vtListTimeSeedTrace *>::iterator trace_iter; // iterator over traces
  std::list<VECTOR4 *>::iterator pt_iter; // iterator over points in one trace
  int rank, nproc; // MPI usual
  int nblocks; // number of blocks in this process
  int tot_npt = 0; // total number of points in all traces from everyone
  int i, j, k;

  if (lat4D != NULL)
    nblocks = lat4D->nb;
  else
    nblocks = latAMR->nb;

  // init
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &nproc);
  if (nflt == NULL)
    assert((nflt = new int[nproc]) != NULL);
  if (ofst == NULL)
    assert((ofst = new int[nproc]) != NULL);
  assert((mypt = new VECTOR4[mynpt]) != NULL);

  // collect my own points
  j = 0;
  for (i = 0; i < nblocks; i++) {
    for (trace_iter = sl_list[i].begin(); trace_iter != sl_list[i].end(); 
         trace_iter++) {
      for (pt_iter = (*trace_iter)->begin(); pt_iter != (*trace_iter)->end(); 
         pt_iter++)
	mypt[j++] = **pt_iter;
    }
  }

  // gather the points at the root
  if (rank == 0) {

    k = 0;
    for (i = 0; i < nproc; i++) {
      nflt[i] = 0;
      for (j = 0; j < ntrace[i]; j++)
	nflt[i] += ((*npt)[k++] * 4);
      ofst[i] = (i == 0) ? 0 : ofst[i - 1] + nflt[i - 1];
    }

  }
  for(i = 0; i < *tot_ntrace; i++)
    tot_npt += (*npt)[i];
  assert((*pt = new VECTOR4[tot_npt]) != NULL);
  MPI_Gatherv(mypt, mynpt * 4, MPI_FLOAT, *pt, nflt, ofst,
	      MPI_FLOAT, 0, MPI_COMM_WORLD);

  delete[] mypt;

}

//-----------------------------------------------------------------------
//
// writes field lines keeping the header distributed
//
// filename: output file name
// id_filename: output id file name
//
void Trace::DistributedWriteFieldlines(char *filename, char *id_filename) {

  MPI_File fd;
  MPI_Status status;
  int myproc;
  float *mypt; // points in my traces
  VECTOR4 temp; // temporary point
  std::list<vtListTimeSeedTrace *>::iterator trace_iter; // iterator over traces
  std::list<VECTOR4 *>::iterator pt_iter; // iterator over points in one trace
  std::list<int64_t>::iterator trace_id_iter; // iterator over trace ids
  float min[4], max[4]; // extents
  int delim = -1; // delimits numbers of points from the points in the file
  int nblocks; // number of blocks in this process
  int tsize; // number of time steps
  float size[3]; // physical domain size
  int i, j, n;
    
  if (lat4D != NULL) {
    nblocks = lat4D->nb;
    tsize = lat4D->ldim;
    size[0] = lat4D->xdim; size[1] = lat4D->ydim; size[2] = lat4D->zdim;
  }
  else {
    nblocks = latAMR->nb;
    tsize = latAMR->tdim;
    size[0] = latAMR->max_extent[0] - latAMR->min_extent[0];
    size[1] = latAMR->max_extent[1] - latAMR->min_extent[1];
    size[2] = latAMR->max_extent[2] - latAMR->min_extent[2];
  }

  MPI_Comm_rank(MPI_COMM_WORLD, &myproc);
  
  int myntrace = 0; // my number of traces
  // compute number of my traces
  for (i = 0; i < nblocks; i++)    
    myntrace += sl_list[i].size();	// write numbers of points in each trace

  int totntrace = 0;
  MPI_Allreduce(&myntrace, &totntrace, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);

  char filename2[1024];
  sprintf(filename2, "fieldlines.%d.out", totntrace);

  assert(MPI_File_open(MPI_COMM_WORLD, filename2, MPI_MODE_CREATE | 
		       MPI_MODE_WRONLY, MPI_INFO_NULL, &fd) == MPI_SUCCESS);
  MPI_File_set_size(fd, 0); // start with an empty file every time

  if (myproc == 0) {

    // write extents
    min[0] = min[1] = min[2] = min[3] = 0.0;
    max[0] = size[0]; max[1] = size[1]; max[2] = size[2]; max[3] = tsize - 1;
    MPI_File_write(fd, min, 4, MPI_FLOAT, &status);
    assert(status.count == 4 * sizeof(float)); // bytes
    MPI_File_write(fd, max, 4, MPI_FLOAT, &status);
    assert(status.count == 4 * sizeof(float)); // bytes
	   
  }

  int *mynpt; // number of points in each of my traces
  int tot_mynpt = 0; // total number of my points

  // compute number of points in each of my traces  
  assert((mynpt = (int *)malloc(sizeof(int) * myntrace)) != NULL);
  j = 0;
  for (i = 0; i < nblocks; i++) {
    for (trace_iter = sl_list[i].begin(); trace_iter != sl_list[i].end();
         trace_iter++) {
      assert(j < myntrace); // sanity
      mynpt[j] = (*trace_iter)->size();
      tot_mynpt += mynpt[j++];
    }
  } 

  // find my offset into the header
  int64_t myntrace64 = myntrace;
  int64_t header_offset = 0;
  MPI_Scan(&myntrace64, &header_offset, 1, MPI_LONG_LONG, 
	   MPI_SUM, MPI_COMM_WORLD);
  header_offset -= myntrace64;
  header_offset *= sizeof(int);
  header_offset += sizeof(float) * 8;

  assert(MPI_File_write_at_all(fd, header_offset, mynpt, myntrace, MPI_INT,
			       &status) == MPI_SUCCESS);
  assert(status.count == myntrace * (int)(sizeof(int)));

  int64_t total_header_size;
  MPI_Allreduce(&myntrace64, &total_header_size, 1, MPI_LONG_LONG, MPI_SUM,
		MPI_COMM_WORLD);

  total_header_size *= sizeof(int);
  total_header_size += sizeof(float) * 8;
  if (myproc == 0) // write delimiter
    assert(MPI_File_write_at(fd, total_header_size, &delim, 1, 
			     MPI_INT, &status) == MPI_SUCCESS);
  total_header_size += sizeof(int);
	
  // find point offset
  int64_t my_point_offset = 0;
  int64_t my_num_points = tot_mynpt;
  MPI_Scan(&my_num_points, &my_point_offset, 1, MPI_LONG_LONG, 
	   MPI_SUM, MPI_COMM_WORLD);
  my_point_offset -= my_num_points;
  my_point_offset *= sizeof(float) * 4;
  my_point_offset += total_header_size;

  // collect my points in a buffer
  assert((mypt = (float *)malloc(tot_mynpt * 4 * sizeof(float))) != NULL);
  n = 0;
  for (i = 0; i < nblocks; i++) {
    for (trace_iter = sl_list[i].begin(); trace_iter != sl_list[i].end(); 
         trace_iter++) {
      for (pt_iter = (*trace_iter)->begin(); pt_iter != (*trace_iter)->end(); 
	   pt_iter++) {
	temp = **pt_iter;
	mypt[4 * n]     = temp[0];
	mypt[4 * n + 1] = temp[1];
	mypt[4 * n + 2] = temp[2];
	mypt[4 * n + 3] = temp[3];
	n++;
      }
    }
  }

  // write my points
  assert(MPI_File_write_at_all(fd, my_point_offset, mypt, tot_mynpt * 4,
			       MPI_FLOAT, &status) == MPI_SUCCESS);
  assert(status.count == tot_mynpt * 4 * (int)(sizeof(float))); // in bytes

  free(mypt);
  MPI_File_close(&fd);

#ifdef TRACK_SEED_ID
  if (id_filename != NULL) {

    char id_filename2[1024];
    sprintf(id_filename2, "fieldline_ids.%d.out", totntrace);
    assert(MPI_File_open(MPI_COMM_WORLD, id_filename2, MPI_MODE_CREATE | 
			 MPI_MODE_WRONLY, MPI_INFO_NULL, &fd) == MPI_SUCCESS);
    int64_t *my_trace_ids = (int64_t *)malloc(sizeof(int64_t) * myntrace);
    assert(my_trace_ids != NULL);
    int32_t which_id = 0;
    for (i = 0; i < nblocks; i++)
      {
	for (trace_id_iter = sl_id_list[i].begin(); 
	     trace_id_iter != sl_id_list[i].end(); trace_id_iter++, which_id++)
	  {
	    assert(which_id < myntrace);
	    my_trace_ids[which_id] = *trace_id_iter;
	  }
      }
    assert(which_id == myntrace);
    header_offset -= sizeof(float) * 8;
    header_offset /= sizeof(int);
    header_offset *= sizeof(int64_t);
    assert(MPI_File_write_at_all(fd, header_offset, my_trace_ids, myntrace,
				 MPI_LONG_LONG, &status) == MPI_SUCCESS);
    MPI_File_close(&fd);
    free(my_trace_ids);
  }
#endif

}
//-----------------------------------------------------------------------
//
// writes field lines
//
// ntrace: number of traces in each process
// mynpt: total number of points in my process
// filename: output file name
//
void Trace::WriteFieldlines(int *ntrace, int mynpt, char *filename) {

  MPI_File fd;
  MPI_Status status;
  int myproc, nproc;
  int64_t ofst; // offset into the file (bytes)
  int64_t pts_ofst = 0; // number of points before mine
  float *mypt; // points in my traces
  VECTOR4 temp; // temporary point
  std::list<vtListTimeSeedTrace *>::iterator trace_iter; // iterator over traces
  std::list<VECTOR4 *>::iterator pt_iter; // iterator over points in one trace
  float min[4], max[4]; // extents
  int delim = -1; // delimits numbers of points from the points in the file
  int nblocks; // number of blocks in this process
  int tsize; // number of timesteps
  float size[3]; // spatial domain size
  int i, j, n;
  int totntrace = 0;
 
  if (lat4D != NULL) {
    nblocks = lat4D->nb;
    tsize = lat4D->ldim;
    size[0] = lat4D->xdim; size[1] = lat4D->ydim; size[2] = lat4D->zdim;
  }
  else {
    nblocks = latAMR->nb;
    tsize = latAMR->tdim;
    size[0] = latAMR->max_extent[0] - latAMR->min_extent[0];
    size[1] = latAMR->max_extent[1] - latAMR->min_extent[1];
    size[2] = latAMR->max_extent[2] - latAMR->min_extent[2];
  }

  MPI_Comm_rank(MPI_COMM_WORLD, &myproc);
  MPI_Comm_size(MPI_COMM_WORLD, &nproc);

  assert(MPI_File_open(MPI_COMM_WORLD, filename, MPI_MODE_CREATE | 
		       MPI_MODE_WRONLY, MPI_INFO_NULL, &fd) == MPI_SUCCESS);
  MPI_File_set_size(fd, 0); // start with an empty file every time

  if (myproc == 0) {

    // write extents
    if (lat4D != NULL) {
    min[0] = min[1] = min[2] = min[3] = 0.0;
    max[0] = size[0]; max[1] = size[1]; max[2] = size[2]; max[3] = tsize - 1;
    }
    else 
      latAMR->GetExtents(min, max);
    MPI_File_write(fd, min, 4, MPI_FLOAT, &status);
    assert(status.count == 4 * sizeof(float)); // bytes
    MPI_File_write(fd, max, 4, MPI_FLOAT, &status);
    assert(status.count == 4 * sizeof(float)); // bytes
	   
    // write numbers of points in each trace
    assert(MPI_File_write(fd, *npt, *tot_ntrace, MPI_INT, 
			  &status) == MPI_SUCCESS);
    assert(status.count == *tot_ntrace * (int)(sizeof(int)));

    // write delimiter
    assert(MPI_File_write(fd, &delim, 1, MPI_INT, &status) == MPI_SUCCESS);

  }

  // find total num traces
  for (i = 0; i < nproc; i++)
    totntrace += ntrace[i];

  // set file pointer to start of my points
  ofst = 8 * sizeof(float) + (*tot_ntrace + 1) * sizeof(int);
  n = 0;
  for (i = 0; i < myproc; i++) {
    for (j = 0; j < ntrace[i]; j++)
      pts_ofst += (*npt)[n++];
  }
  ofst += pts_ofst * 4 * sizeof(float); // pts before mine

  // collect my points in a buffer
  assert((mypt = (float *)malloc(mynpt * 4 * sizeof(float))) != NULL);
  n = 0;
  for (i = 0; i < nblocks; i++) {
    for (trace_iter = sl_list[i].begin(); trace_iter != sl_list[i].end(); 
         trace_iter++) {
      for (pt_iter = (*trace_iter)->begin(); pt_iter != (*trace_iter)->end(); 
	   pt_iter++) {
	temp = **pt_iter;
	mypt[4 * n]     = temp[0];
	mypt[4 * n + 1] = temp[1];
	mypt[4 * n + 2] = temp[2];
	mypt[4 * n + 3] = temp[3];
	n++;
      }
    }
  }

  // write my points
  MPI_File_set_view(fd, ofst, MPI_FLOAT, MPI_FLOAT, (char *)"native", 
		    MPI_INFO_NULL);
  assert(MPI_File_write_all(fd, mypt, mynpt * 4, MPI_FLOAT, &status)
	 == MPI_SUCCESS);
  assert(status.count == mynpt * 4 * (int)(sizeof(float))); // in bytes

  free(mypt);
  MPI_File_close(&fd);
	
}
//-----------------------------------------------------------------------
void Trace::InitSeedLists4D() {

  int npart; // total number of partitions

  if (lat4D != NULL)
    npart = lat4D->npart;
  else
    npart = latAMR->npart;

  seedlists4D = new list<VECTOR4>[npart]; 

  for (int i = 0; i < npart; i++)
    seedlists4D[i].clear(); 

}
//--------------------------------------------------------------------------
void Trace::InitSeedLists3D() {

  int npart = lat4D->npart; // total number of partitions

  seedlists3D = new list<VECTOR3>[npart]; 

  for (int i = 0; i < npart; i++)
    seedlists3D[i].clear(); 

}
//--------------------------------------------------------------------------
//
void Trace::ResetSeedLists4D() {

  int npart; // total number of partitions

  if (lat4D != NULL)
    npart = lat4D->npart;
  else
    npart = latAMR->npart;

  for (int i = 0; i < npart; i++)
    seedlists4D[i].clear(); 

}
//--------------------------------------------------------------------------
//
void Trace::ResetSeedLists3D() {

  int npart = lat4D->npart; // total number of partitions

  for (int i = 0; i < npart; i++)
    seedlists3D[i].clear(); 

}
//--------------------------------------------------------------------------
//
bool Trace::InsertSeed(int i, int j, int k, int t, VECTOR4 p) {

  int rank;
  if (lat4D != NULL)
    rank = lat4D->GetRank(i, j, k, t);
  else
    rank = latAMR->GetRank(i, j, k,t);

  if (rank ==-1) return(false); 

  seedlists4D[rank].push_back(p); 
  return(true); 

}
//--------------------------------------------------------------------------
//
bool Trace::InsertSeed(int i, int j, int k, VECTOR3 p) {

  int rank = lat4D->GetRank(i, j, k, 0); // not using t

  if (rank ==-1) return(false); 

  seedlists3D[rank].push_back(p); 
  return(true); 

}
//--------------------------------------------------------------------------
//
bool Trace::InsertSeed(int from_i, int from_j, int from_k, int from_t, 
			   int i, int j, int k, int t, VECTOR4 p) {

  int npart; // total number of partitions
  int from_rank;
  int to_rank;

  if (lat4D != NULL) {
    npart = lat4D->npart;
    from_rank = lat4D->GetRank(from_i, from_j, from_k, from_t); 
    to_rank = lat4D->GetRank(i,j,k,t); 
  } else {
    npart = latAMR->npart;
    from_rank = latAMR->GetRank(from_i, from_j, from_k, from_t); 
    to_rank = latAMR->GetRank(i,j,k, t); 
  }

  if (to_rank ==-1 || from_rank==-1) return(false); 

  seedlists4D[to_rank].push_back(p); 
  flowMatrix[from_rank*npart+to_rank]++; 
  return(true); 


}
//--------------------------------------------------------------------------
//
bool Trace::InsertSeed(int from_i, int from_j, int from_k,
			   int i, int j, int k, VECTOR3 p) {

  int npart; // total number of partitions
  int from_rank;
  int to_rank;

  npart = lat4D->npart;
  from_rank = lat4D->GetRank(from_i, from_j, from_k, 0); // not using t
  to_rank = lat4D->GetRank(i,j,k,0); // not using t

  if (to_rank ==-1 || from_rank==-1) return(false); 

  seedlists3D[to_rank].push_back(p); 
  flowMatrix[from_rank*npart+to_rank]++; 
  return(true); 

}
//--------------------------------------------------------------------------
//
bool Trace::InsertSeed(int i, VECTOR4 p) {

  int npart; // total number of partitions

  if (lat4D != NULL)
    npart = lat4D->npart;
  else
    npart = latAMR->npart;

  if (i>=npart) return(false); 

  seedlists4D[i].push_back(p); 
  return(true); 

}
//--------------------------------------------------------------------------
//
bool Trace::InsertSeed(int i, VECTOR3 p) {

  int npart = lat4D->npart; // total number of partitions

  if (i>=npart) return(false); 

  seedlists3D[i].push_back(p); 
  return(true); 

}
//--------------------------------------------------------------------------
//
bool Trace::InsertSeed(int from_rank, int to_rank, VECTOR4 p) {

  int npart; // total number of partitions

  if (lat4D != NULL)
    npart = lat4D->npart;
  else
    npart = latAMR->npart;

  if (from_rank >=npart || to_rank>=npart) return(false); 

  flowMatrix[from_rank*npart+to_rank]++; 
  seedlists4D[to_rank].push_back(p); 
  return(true); 

}
//---------------------------------------------------------------------------
//
bool Trace::InsertSeed(int from_rank, int to_rank, VECTOR3 p) {

  int npart = lat4D->npart; // total number of partitions

  if (from_rank >=npart || to_rank>=npart) return(false); 

  flowMatrix[from_rank*npart+to_rank]++; 
  seedlists3D[to_rank].push_back(p); 
  return(true); 

}
//---------------------------------------------------------------------------
//
void Trace::ResetFlowMatrix() {

  int npart; // total number of partitions

  if (lat4D != NULL)
    npart = lat4D->npart;
  else
    npart = latAMR->npart;

  if (flowMatrix !=NULL) 
    memset(flowMatrix, '\0', npart*npart*sizeof(int)); 

}
//--------------------------------------------------------------------------
//
int Trace::GetFlowMatrix(int i, int j) {

  int npart; // total number of partitions

  if (lat4D != NULL)
    npart = lat4D->npart;
  else
    npart = latAMR->npart;

  return flowMatrix[i*npart+j];

}
//--------------------------------------------------------------------------

// MPI version of communication

#ifdef _MPI

//---------------------------------------------------------------------------
//
// DEPRECATED
//
// exhanges points with all neighbors
//
// seeds: locations to store received points, indexed by local block number
// size_seeds: sizes of seed arrays (will be grown automatically if necessary)
// num_seeds: number of seeds stored for each block
// seed_ids: seed ids for each block
//
// returns: total number of points received by this process
//
int Trace::OldExchangeNeighbors(VECTOR4 **seeds, int *size_seeds, 
				int *num_seeds, int64_t **seed_ids) {

  static float ***fseeds = NULL; // seeds ready for exchanging
  static int *alloc_fseeds = NULL; // number of seeds allocated in fseeds
  static int alloc_fblocks = 0; // number of blocks allocated in alloc_fseeds
  int b; // block number
  int npr = 0; // number of sending and receiving points
  int i;

  // must pass seed ids if tracking is turned on
  assert((seed_ids != NULL && track_seed_id == true) ||
	 (seed_ids == NULL && track_seed_id == false));
	
  // init num_seeds for my blocks
  for (i = 0; i < nb; i++)
    num_seeds[i] = 0;

  // grow size of fseeds (floating point version of seeds)
  if (!alloc_fblocks) {
    assert((alloc_fseeds = (int *)malloc(nb * sizeof(int))) != NULL);
    alloc_fblocks = nb;
    assert((fseeds = (float ***)malloc(nb * sizeof(float **))) != NULL);
    for (b = 0; b < nb; b++)
      alloc_fseeds[b] = 0;
  }

  // exchange
  if (lat4D != NULL)
    npr = lat4D->OldExchangeNeighbors(fseeds, alloc_fseeds, num_seeds, 
				   seed_ids);
  else
    npr = latAMR->OldExchangeNeighbors(fseeds, alloc_fseeds, num_seeds, 
				   seed_ids);

  comm_time2 = MPI_Wtime() - comm_time2;
  comm_time3 = MPI_Wtime();

  // copy received (float) seeds to VEC4 seeds
  for (b = 0; b < nb; b++) {

    // grow size of seeds (native version of seeds)
    if (!size_seeds[b]) {
      assert((seeds[b] = (VECTOR4 *)
	      malloc((num_seeds[b]) * sizeof(VECTOR4))) != NULL);

      if (track_seed_id)
	assert((seed_ids[b] = (int64_t *)
		malloc((num_seeds[b]) * sizeof(int64_t))) != NULL);

      size_seeds[b] = (num_seeds[b]) * 4 * sizeof(VECTOR4);
    }
    while (size_seeds[b] < (num_seeds[b]) * 4 * (int)(sizeof(VECTOR4))) {
      assert((seeds[b] = (VECTOR4 *)realloc(seeds[b], 
					   size_seeds[b] * 2)) != NULL);

      if (track_seed_id)
	// divide by 2 because seed ids are half the size of seeds
	assert((seed_ids[b] = 
		(int64_t *)realloc(seed_ids[b],
				   size_seeds[b] * 2 / 2)) != NULL);
	
      size_seeds[b] *= 2;
    }

    // copy points to seeds
    for (i = 0; i < num_seeds[b]; i++) {
      seeds[b][i][0] = fseeds[b][i][0];
      seeds[b][i][1] = fseeds[b][i][1];
      seeds[b][i][2] = fseeds[b][i][2];
      seeds[b][i][3] = fseeds[b][i][3];
    }

  }

  return npr;

}
//------------------------------------------------------------------------
//
// exhanges points with all neighbors
//
// stable, synchronous version
//
// seeds: locations to store received points, indexed by local block number
// size_seeds: sizes of seed arrays (will be grown automatically if necessary)
// num_seeds: number of seeds stored for each block
// seed_ids: seed ids for each block
//
// returns: total number of points received by this process
//
int Trace::SyncExchangeNeighbors(VECTOR4 **seeds, int *size_seeds, 
				 int *num_seeds, int64_t **seed_ids) {

  static float **points; // receiving points
  static int **counts; // receiving point counts
  static int64_t **point_ids; // receiving point ids
  int b; // block number
  int npr; // number of received points
  static int nproc; // number of processes sending me messages
  int p; // process id
  int r; // partition rank
  Partition4D *parts; // pointer to partition data structure
  int i, j, k, m, n, q;

  // must pass seed ids if tracking is turned on
  assert((seed_ids != NULL && track_seed_id == true) ||
	 (seed_ids == NULL && track_seed_id == false));
	
  if (lat4D != NULL)
    parts = lat4D->part->parts;
  else
    parts = latAMR->part->parts;

  // init num_seeds for my blocks
  for (i = 0; i < nb; i++)
    num_seeds[i] = 0;

  // exchange
  if (lat4D != NULL) {
    if (track_seed_id)
      npr = lat4D->SyncExchangeNeighbors(&nproc, &points, &counts, &point_ids);
    else
      npr = lat4D->SyncExchangeNeighbors(&nproc, &points, &counts);
  }
  else {
    if (track_seed_id)
      npr = latAMR->SyncExchangeNeighbors(&nproc, &points, &counts, 
					   &point_ids);
    else
      npr = latAMR->SyncExchangeNeighbors(&nproc, &points, &counts);
  }

  // copy received points to seeds
  for (p = 0; p < nproc; p++) { // processes sending me messages

    m = 1; // index in counts
    k = 0; // index in points
    q = 0; // index in point ids
    for (i = 0; i < counts[p][0]; i++) { // all blocks in the received message

      // my block number of the next points in the message
      for (b = 0; b < nb; b++) {
	if (lat4D != NULL && lat4D->GetRank(b) == counts[p][m])
	  break;
	if (latAMR != NULL && latAMR->GetRank(b) == counts[p][m])
	  break;
      }
      assert(b < nb); // sanity
      r = counts[p][m++]; // partition rank of this block
      n = counts[p][m++]; // number of points recieved by this block

      // grow size of seeds
      if (!size_seeds[b] && num_seeds[b] + n) {
	assert((seeds[b] = (VECTOR4 *)
		malloc((num_seeds[b] + n) * sizeof(VECTOR4))) != NULL);

	if (track_seed_id)
	  assert((seed_ids[b] = (int64_t *)
		  malloc((num_seeds[b] + n) * sizeof(int64_t))) != NULL);

	size_seeds[b] = (num_seeds[b] + n) * 4 * sizeof(VECTOR4);
      }
      while (size_seeds[b] < (num_seeds[b] + n) * 4 * (int)(sizeof(VECTOR4))) {
	assert((seeds[b] = (VECTOR4 *)realloc(seeds[b], 
					      size_seeds[b] * 2)) != NULL);
	if (track_seed_id)
	  // seed ids are half the size of seeds
	  assert((seed_ids[b] = 
		  (int64_t *)realloc(seed_ids[b],
				     size_seeds[b])) != NULL);
	size_seeds[b] *= 2;
      }

      // copy points to seeds
      for (j = 0; j < n; j++) {
	seeds[b][num_seeds[b]][0] = points[p][k++];
	seeds[b][num_seeds[b]][1] = points[p][k++];
	seeds[b][num_seeds[b]][2] = points[p][k++];
	seeds[b][num_seeds[b]][3] = points[p][k++];
	if (track_seed_id)
	  seed_ids[b][num_seeds[b]] = point_ids[p][q++];
	num_seeds[b]++;

      }

    } // all blocks in the received message

  } // processes sending me messages

  return npr;

}
//---------------------------------------------------------------------------
//
// exhanges points with all neighbors
//
// new, asynchronous version
//
// seeds: locations to store received points, indexed by local block number
// size_seeds: sizes of seed arrays (will be grown automatically if necessary)
// num_seeds: number of seeds stored for each block
// seed_ids: seed ids for each block
//
// returns: total number of points received by this process
//
int Trace::AsyncExchangeNeighbors(VECTOR4 **seeds, int *size_seeds, 
				  int *num_seeds, int64_t **seed_ids) {

  float **points; // receiving points
  int **counts; // receiving point counts
  int64_t **point_ids; // receiving point ids
  int b; // block number
  int npr; // number of received points
  int nproc; // number of processes sending me messages
  int p; // process id
  int r; // partition rank
  Partition4D *parts; // pointer to partition data structure
  int i, j, k, m, n, q;

  // must pass seed ids if tracking is turned on
  assert((seed_ids != NULL && track_seed_id == true) ||
	 (seed_ids == NULL && track_seed_id == false));
	
  if (lat4D != NULL)
    parts = lat4D->part->parts;
  else
    parts = latAMR->part->parts;

  // init num_seeds for my blocks
  for (i = 0; i < nb; i++)
    num_seeds[i] = 0;

  // exchange
  if (lat4D != NULL) {
    if (track_seed_id)
      npr = lat4D->AsyncExchangeNeighbors(&nproc, &points, &counts, &point_ids);
    else
      npr = lat4D->AsyncExchangeNeighbors(&nproc, &points, &counts);
  }
  else {
    if (track_seed_id)
      npr = latAMR->AsyncExchangeNeighbors(&nproc, &points, &counts, 
					   &point_ids);
    else
      npr = latAMR->AsyncExchangeNeighbors(&nproc, &points, &counts);
  }

  // copy received points back to seeds
  PointsToSeeds(seeds, size_seeds, num_seeds, seed_ids, points, counts,
		point_ids, nproc);

  // clean up
  for (i = 0; i < nproc; i++) {
    delete[] counts[i];
    delete[] points[i];
    if (track_seed_id)
      delete[] point_ids[i];
  }
  if (nproc > 0) {
    delete[] counts;
    delete[] points;
    if (track_seed_id)
      delete[] point_ids;
  }

  return npr;

}
//---------------------------------------------------------------------------
//
// copies exhanged points to seeds
//
// new, asynchronous version
//
// seeds: locations to store received points, indexed by local block number
// size_seeds: sizes of seed arrays (will be grown automatically if necessary)
// num_seeds: number of seeds stored for each block
// seed_ids: seed ids for each block
// nproc: number of processes from which messages arrived = number of messages
//
void Trace::PointsToSeeds(VECTOR4 **seeds, int *size_seeds, int *num_seeds, 
			  int64_t **seed_ids, float **points, int **counts,
			  int64_t **point_ids, int nproc) {

  int b; // block number
  int r; // partition rank
  int p; // process id
  int i, j, k, m, n, q;

  for (p = 0; p < nproc; p++) { // processes sending me messages

    m = 1; // index in counts
    k = 0; // index in points
    q = 0; // index in point ids
    for (i = 0; i < counts[p][0]; i++) { // all blocks in the received message

      // my block number of the next points in the message
      for (b = 0; b < nb; b++) {
	if (lat4D != NULL && lat4D->GetRank(b) == counts[p][m])
	  break;
	if (latAMR != NULL && latAMR->GetRank(b) == counts[p][m])
	  break;
      }
      assert(b < nb); // sanity
      r = counts[p][m++]; // partition rank of this block
      n = counts[p][m++]; // number of points recieved by this block

      // grow size of seeds
      if (!size_seeds[b] && num_seeds[b] + n) {
	assert((seeds[b] = (VECTOR4 *)
		malloc((num_seeds[b] + n) * sizeof(VECTOR4))) != NULL);

	if (track_seed_id)
	  assert((seed_ids[b] = (int64_t *)
		  malloc((num_seeds[b] + n) * sizeof(int64_t))) != NULL);

	size_seeds[b] = (num_seeds[b] + n) * 4 * sizeof(VECTOR4);
      }
      while (size_seeds[b] < (num_seeds[b] + n) * 4 * (int)(sizeof(VECTOR4))) {
	assert((seeds[b] = (VECTOR4 *)realloc(seeds[b], 
					      size_seeds[b] * 2)) != NULL);
	if (track_seed_id)
	  // seed ids are half the size of seeds
	  assert((seed_ids[b] = 
		  (int64_t *)realloc(seed_ids[b],
				     size_seeds[b])) != NULL);
	size_seeds[b] *= 2;
      }

      // copy points to seeds
      for (j = 0; j < n; j++) {
	seeds[b][num_seeds[b]][0] = points[p][k++];
	seeds[b][num_seeds[b]][1] = points[p][k++];
	seeds[b][num_seeds[b]][2] = points[p][k++];
	seeds[b][num_seeds[b]][3] = points[p][k++];
	if (track_seed_id)
	  seed_ids[b][num_seeds[b]] = point_ids[p][q++];
 	num_seeds[b]++;

     }

    } // all blocks in the received message

  } // processes sending me messages

}
//---------------------------------------------------------------------------
//
// completes neighbor exhange
//
// seeds: locations to store received points, indexed by local block number
// size_seeds: sizes of seed arrays (will be grown automatically if necessary)
// num_seeds: number of seeds stored for each block
// seed_ids: seed ids for each block
//
// returns: total number of points received
//
int Trace::AsyncFlush(VECTOR4 **seeds, int *size_seeds, 
		      int *num_seeds, int64_t **seed_ids) {

  static float **points; // receiving points
  static int **counts; // receiving point counts
  static int64_t **point_ids; // receiving point ids
  static int nproc; // number of processes sending me messages
  int npr; // total number of points received
  int i;

  if (lat4D != NULL) {
    if (track_seed_id)
      npr = lat4D->FlushExchangeNeighbors(&nproc, &points, &counts, &point_ids);
    else
      npr = lat4D->FlushExchangeNeighbors(&nproc, &points, &counts);
  }
  else {
    if (track_seed_id)
      npr = latAMR->FlushExchangeNeighbors(&nproc, &points, &counts, 
					   &point_ids);
    else
      npr = latAMR->FlushExchangeNeighbors(&nproc, &points, &counts);
  }

  // copy received points back to seeds
  PointsToSeeds(seeds, size_seeds, num_seeds, seed_ids, points, counts,
		point_ids, nproc);

  // clean up
  for (i = 0; i < nproc; i++) {
    delete[] counts[i];
    delete[] points[i];
    if (track_seed_id)
      delete[] point_ids[i];
  }
  if (nproc > 0) {
    delete[] counts;
    delete[] points;
    if (track_seed_id)
      delete[] point_ids;
  }

  return npr;

}
//------------------------------------------------------------------------

#endif

// serial version of communication


//---------------------------------------------------------------------------
//
// exhanges points with all neighbors
//
// seeds: locations to store received points, indexed by global partition rank
// size_seeds: sizes of seed arrays (will be grown automatically if necessary)
// num_seeds: number of seeds stored for each partition
//
// returns: total number of points exchanged
//
int Trace::SerExchangeNeighbors(VECTOR4 **seeds, int *size_seeds, int *num_seeds) {

  int r; // destination (global) rank
  int np = 0; // total number of points
  int n; // number of seeds going from one block to another
  int npart; // total number of partitions
  Partition4D *parts; // pointer to partition data structure
  int i, j, k;
  int **neighbor_ranks; // ranks of neighbors of my blocks

  if (lat4D != NULL) {
    neighbor_ranks = lat4D->neighbor_ranks;
    npart = lat4D->npart;
    parts = lat4D->part->parts;
  }
  else {
    neighbor_ranks = latAMR->neighbor_ranks;
    npart = latAMR->npart;
    parts = latAMR->part->parts;
  }

  // init num_seeds for my blocks
  for (i = 0; i < nb; i++)
    num_seeds[i] = 0;

  // i is global rank of partition
  for (i = 0; i < npart; i++) {

    // j is (local) neighbor number in i's neighbor list
    for (j = 0; j < parts[i].NumNeighbors; j++) {

      r = neighbor_ranks[i][j]; // global rank of destination

      // number of points going to this neighbor
      n = parts[i].NumSendPoints[j];

      // grow size of seeds
      if (!size_seeds[r]) {
	assert((seeds[r] = (VECTOR4 *)malloc((num_seeds[r] + n) * 4 *
					     sizeof(VECTOR4))) != NULL);
	size_seeds[r] = (num_seeds[r] + n) * 4 * sizeof(VECTOR4);
      }
      while (size_seeds[r] < (num_seeds[r] + n) * 4 * (int)(sizeof(VECTOR4))) {
	assert((seeds[r] = (VECTOR4 *)realloc(seeds[r], size_seeds[r] * 2))
	       != NULL);
	size_seeds[r] *= 2;
      }

      // copy points to seeds
      for (k = 0; k < n; k++) {
	seeds[r][num_seeds[r]][0] = parts[i].SendPoints[j][4 * k];
	seeds[r][num_seeds[r]][1] = parts[i].SendPoints[j][4 * k + 1];
	seeds[r][num_seeds[r]][2] = parts[i].SendPoints[j][4 * k + 2];
	seeds[r][num_seeds[r]][3] = parts[i].SendPoints[j][4 * k + 3];
	num_seeds[r]++;
	np++;
      }

      parts[i].NumSendPoints[j] = 0;

    } // neighbor of partition rank

  } // global partition rank

  return np;

}
//------------------------------------------------------------------------

#ifdef ZOLTAN

//---------------------------------------------------------------------------
//
// wrapper for changing the partition
// assumes some existing paritition is in place already
//
// grp: time group
// nblocks: current number of my blocks (will be updated by Repartition)
// seeds: locations to store received points, indexed by local block number
// size_seeds: sizes of seed arrays (will be grown automatically if necessary)
// num_seeds: number of seeds stored for each block
// type: type of repartitioning algorithm used
//       0 = geometry-based (RCB)
//       1 = graph-based (not yet implemented)
// osuflow: pointer to array of osuflow objects for this process
// block: pointer to block class object
// comm: MPI communicator
// wgts: weights of blocks
//
void Trace::Repartition(int grp, int *nblocks, VECTOR4 ***seeds, 
			int **size_seeds, int **num_seeds, int type, 
			OSUFlow ***osuflow, Block *block, int compute_type,
			MPI_Comm comm, int *wgts) {

  Partition *part; // pointer to partition data structure
  int **block_ranks; // ranks of my blocks
  int ***neighbor_ranks; // ranks of neighbors of my blocks
  int ***neighbor_procs; // procs of neighbors of my blocks
  int *avg_neigh; // average number of neighbors
  int *alloc_blocks; // allocated number of blocks
  int **alloc_neighbors; // allocated size of neighbor_ranks, neighbor_procs

  if (lat4D != NULL) {
    block_ranks = &lat4D->block_ranks;
    neighbor_ranks = &lat4D->neighbor_ranks;
    neighbor_procs = &lat4D->neighbor_procs;
    avg_neigh = &lat4D->avg_neigh;
    alloc_blocks = &lat4D->alloc_blocks;
    alloc_neighbors = &lat4D->alloc_neighbors;
    part = lat4D->part;
  }
  else {
    block_ranks = &latAMR->block_ranks;
    neighbor_ranks = &latAMR->neighbor_ranks;
    neighbor_procs = &latAMR->neighbor_procs;
    avg_neigh = &latAMR->avg_neigh;
    alloc_blocks = &latAMR->alloc_blocks;
    alloc_neighbors = &latAMR->alloc_neighbors;
    part = latAMR->part;
  }

  // only geometry-based so far
  assert(type == 0);

  ChangePartition(grp, nblocks, block_ranks, neighbor_ranks, neighbor_procs, 
		  part, seeds, size_seeds, num_seeds, avg_neigh, alloc_blocks, 
		  alloc_neighbors, MPI_COMM_WORLD, osuflow, &AddNeighbor, wgts);

  // update number of blocks
  nb = *nblocks; //Trace's version
  if (lat4D != NULL) // Lattice's version
    lat4D->nb = *nblocks;
  else
    latAMR->nb = *nblocks;

  // update Trace's version of seed info
  this->Seeds = *seeds;
  this->NumSeeds = *num_seeds;

  // update Trace's and Block's version of osuflow info
  UpdateOSUFlow(*osuflow);
  block->UpdateCompute((void *)*osuflow, compute_type);

}
//---------------------------------------------------------------------------

#endif

//---------------------------------------------------------------------------
//
// prints performance stats
//
void Trace::PrintPerf(double TotTime, double TotIOTime, double TotCommTime, 
		      double TotCompTime, double TotOutTime,
		      int TotParticles) {

  float size[3]; // number of grid points

  if (lat4D != NULL) {
    size[0] =lat4D->xdim; size[1] = lat4D->ydim; size[2] = lat4D->zdim;
  }
  else {
    // npart gets multiplied only once so the total is right
    size[0] = latAMR->npart * latAMR->block_dims[0];
    size[1] = latAMR->block_dims[1]; 
    size[2] = latAMR->block_dims[2];
  }

  int nproc;  // mpi groupsize
  int rank; // mpi rank
  int *all_block_stats; // gathered block stats
  double *all_time_stats; // gathered time stats
  float TotCells; // total number of spatial data cells in billions
  float TotDataSize; // total size of a time step in GB
  int i;

  int tot_npart = 0; // number of partitions per proc
  int min_npart = 0;
  int max_npart = 0;
  int mean_npart;
  float var_npart = 0.0;
  float std_npart;

  int tot_nneigh = 0; // number of neighbors 
  int min_nneigh = 0;
  int max_nneigh = 0;
  int mean_nneigh;
  float var_nneigh = 0.0;
  float std_nneigh;

  int tot_nseed = 0; // number of seeds
  int min_nseed = 0;
  int max_nseed = 0;
  int p_min_nseed = 0;
  int p_max_nseed = 0;
  int mean_nseed;
  float var_nseed = 0.0;
  float std_nseed;

  int tot_nstep = 0; // number of steps
  int min_nstep = 0;
  int max_nstep = 0;
  int p_min_nstep = 0;
  int p_max_nstep = 0;
  int mean_nstep;
  float var_nstep = 0.0;
  float std_nstep;

  int tot_nptsend = 0; // total number of points sent
  int min_nptsend = 0;
  int max_nptsend = 0;
  int p_min_nptsend = 0;
  int p_max_nptsend = 0;
  int mean_nptsend;
  float var_nptsend = 0.0;
  float std_nptsend;

  double tot_iotime = 0.0; // I/O time
  double min_iotime = 0;
  double max_iotime = 0;
  int p_min_iotime = 0;
  int p_max_iotime = 0;
  double mean_iotime;
  double var_iotime = 0.0;
  double std_iotime;

  double tot_commtime = 0.0; // communication time
  double min_commtime = 0;
  double max_commtime = 0;
  int p_min_commtime = 0;
  int p_max_commtime = 0;
  double mean_commtime;
  double var_commtime = 0.0;
  double std_commtime;

  double tot_comptime = 0.0; // computation time
  double min_comptime = 0;
  double max_comptime = 0;
  int p_min_comptime = 0;
  int p_max_comptime = 0;
  double mean_comptime;
  double var_comptime = 0.0;
  double std_comptime;

  double tot_outtime = 0.0; // output time
  double min_outtime = 0;
  double max_outtime = 0;
  int p_min_outtime = 0;
  int p_max_outtime = 0;
  double mean_outtime;
  double var_outtime = 0.0;
  double std_outtime;

  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &nproc);

  // get stats of my process
  if (lat4D != NULL) {
  block_stats[0] = lat4D->GetMyNumPartitions(); // number of blocks
  block_stats[1] = lat4D->GetMyNumNeighbors(); // avg number of neighbors
  block_stats[3] = lat4D->GetMyTotPtsSend(); // total points sent
  }
  else {
  block_stats[0] = latAMR->GetMyNumPartitions(); // number of blocks
  block_stats[1] = latAMR->GetMyNumNeighbors(); // avg number of neighbors
  block_stats[3] = latAMR->GetMyTotPtsSend(); // total points sent
  }
  block_stats[2] = TotSeeds; // total number of particles advected
  block_stats[4] = TotSteps; // total number of steps advected

  time_stats[0] = TotIOTime; // I/O time
  time_stats[1] = TotCommTime; // communication time
  time_stats[2] = TotCompTime; // computation time
  time_stats[3] = TotOutTime; // output time

  // alloc space and gather the stats
  assert((all_block_stats = (int *)malloc(n_block_stats * nproc * 
					  sizeof(int))) != NULL);
  assert((all_time_stats = (double *)malloc(n_time_stats * nproc * 
					    sizeof(double))) != NULL);
  MPI_Gather(block_stats, n_block_stats, MPI_INT, all_block_stats, 
	     n_block_stats, MPI_INT, 0, MPI_COMM_WORLD);
  MPI_Gather(time_stats, n_time_stats, MPI_DOUBLE, all_time_stats, 
	     n_time_stats, MPI_DOUBLE, 0, MPI_COMM_WORLD);

  // print the stats
  if (rank == 0) {

    // totals, mins, maxs
    for (i = 0; i < nproc; i++) {

      // total
      tot_npart    += all_block_stats[n_block_stats * i];
      tot_nneigh   += all_block_stats[n_block_stats * i + 1];
      tot_nseed    += all_block_stats[n_block_stats * i + 2];
      tot_nptsend  += all_block_stats[n_block_stats * i + 3];
      tot_nstep    += all_block_stats[n_block_stats * i + 4];
      tot_iotime   += all_time_stats[n_time_stats * i];
      tot_commtime += all_time_stats[n_time_stats * i + 1];
      tot_comptime += all_time_stats[n_time_stats * i + 2];
      tot_outtime  += all_time_stats[n_time_stats * i + 3];

      // min, max
      if (i == 0) {
	min_npart = max_npart       = all_block_stats[n_block_stats * i];
	min_nneigh = max_nneigh     = all_block_stats[n_block_stats * i + 1];
	min_nseed = max_nseed       = all_block_stats[n_block_stats * i + 2];
	min_nptsend = max_nptsend   = all_block_stats[n_block_stats * i + 3];
	min_nstep = max_nstep       = all_block_stats[n_block_stats * i + 4];
	min_iotime = max_iotime     = all_time_stats[n_time_stats * i];
	min_commtime = max_commtime = all_time_stats[n_time_stats * i + 1];
	min_comptime = max_comptime = all_time_stats[n_time_stats * i + 2];
	min_outtime = max_outtime   = all_time_stats[n_time_stats * i + 3];
	p_min_nseed = p_max_nseed = 0;
	p_min_nptsend = p_max_nptsend = 0;
	p_min_nstep = p_max_nstep = 0;
	p_min_iotime = p_max_iotime = 0;
	p_min_commtime = p_max_commtime = 0;
	p_min_comptime = p_max_comptime = 0;
	p_min_outtime = p_max_outtime = 0;
      }
      else {

	if (all_block_stats[n_block_stats * i] < min_npart)
	  min_npart = all_block_stats[n_block_stats * i];
	if (all_block_stats[n_block_stats * i] > max_npart)
	  max_npart = all_block_stats[n_block_stats * i];

	if (all_block_stats[n_block_stats * i + 1] < min_nneigh)
	  min_nneigh = all_block_stats[n_block_stats * i + 1];
	if (all_block_stats[n_block_stats * i + 1] > max_nneigh)
	  max_nneigh = all_block_stats[n_block_stats * i + 1];

	if (all_block_stats[n_block_stats * i + 2] < min_nseed) {
	  min_nseed = all_block_stats[n_block_stats * i + 2];
	  p_min_nseed = i;
	}
	if (all_block_stats[n_block_stats * i + 2] > max_nseed) {
	  max_nseed = all_block_stats[n_block_stats * i + 2];
	  p_max_nseed = i;
	}

	if (all_block_stats[n_block_stats * i + 3] < min_nptsend) {
	  min_nptsend = all_block_stats[n_block_stats * i + 3];
	  p_min_nptsend = i;
	}
	if (all_block_stats[n_block_stats * i + 3] > max_nptsend) {
	  max_nptsend = all_block_stats[n_block_stats * i + 3];
	  p_max_nptsend = i;
	}

	if (all_block_stats[n_block_stats * i + 4] < min_nstep) {
	  min_nstep = all_block_stats[n_block_stats * i + 4];
	  p_min_nstep = i;
	}
	if (all_block_stats[n_block_stats * i + 4] > max_nstep) {
	  max_nstep = all_block_stats[n_block_stats * i + 4];
	  p_max_nstep = i;
	}

	if (all_time_stats[n_time_stats * i] < min_iotime) {
	  min_iotime = all_time_stats[n_time_stats * i];
	  p_min_iotime = i;
	}
	if (all_time_stats[n_time_stats * i] > max_iotime) {
	  max_iotime = all_time_stats[n_time_stats * i];
	  p_max_iotime = i;
	}

	if (all_time_stats[n_time_stats * i + 1] < min_commtime) {
	  min_commtime = all_time_stats[n_time_stats * i + 1];
	  p_min_commtime = i;
	}
	if (all_time_stats[n_time_stats * i + 1] > max_commtime) {
	  max_commtime = all_time_stats[n_time_stats * i + 1];
	  p_max_commtime = i;
	}

	if (all_time_stats[n_time_stats * i + 2] < min_comptime) {
	  min_comptime = all_time_stats[n_time_stats * i + 2];
	  p_min_comptime = i;
	}
	if (all_time_stats[n_time_stats * i + 2] > max_comptime) {
	  max_comptime = all_time_stats[n_time_stats * i + 2];
	  p_max_comptime = i;
	}

	if (all_time_stats[n_time_stats * i + 3] < min_outtime) {
	  min_outtime = all_time_stats[n_time_stats * i + 3];
	  p_min_outtime = i;
	}
	if (all_time_stats[n_time_stats * i + 3] > max_outtime) {
	  max_outtime = all_time_stats[n_time_stats * i + 3];
	  p_max_outtime = i;
	}

      }
    }

    // means
    mean_npart = tot_npart / nproc;
    mean_nneigh = tot_nneigh / nproc;
    mean_nseed = tot_nseed / nproc;
    mean_nptsend = tot_nptsend / nproc;
    mean_nstep = tot_nstep / nproc;
    mean_iotime = tot_iotime / nproc;
    mean_commtime = tot_commtime / nproc;
    mean_comptime = tot_comptime / nproc;
    mean_outtime = tot_outtime / nproc;

    // variances
    for (i = 0; i < nproc; i++) {
      var_npart += (all_block_stats[n_block_stats * i] - mean_npart) *
	(all_block_stats[n_block_stats * i] - mean_npart);
      var_nneigh += (all_block_stats[n_block_stats * i + 1] - mean_nneigh) *
	(all_block_stats[n_block_stats * i + 1] - mean_nneigh);
      var_nseed += (all_block_stats[n_block_stats * i + 2] - mean_nseed) *
	(all_block_stats[n_block_stats * i + 2] - mean_nseed);
      var_nptsend += (all_block_stats[n_block_stats * i + 3] - mean_nptsend) *
	(all_block_stats[n_block_stats * i + 3] - mean_nptsend);
      var_nstep += (all_block_stats[n_block_stats * i + 4] - mean_nstep) *
	(all_block_stats[n_block_stats * i + 4] - mean_nstep);
      var_iotime += (all_time_stats[n_time_stats * i] - mean_iotime) *
	(all_time_stats[n_time_stats * i] - mean_iotime);
      var_commtime += (all_time_stats[n_time_stats * i + 1] - mean_commtime) *
	(all_time_stats[n_time_stats * i + 1] - mean_commtime);
      var_comptime += (all_time_stats[n_time_stats * i + 2] - mean_comptime) *
	(all_time_stats[n_time_stats * i + 2] - mean_comptime);
      var_outtime += (all_time_stats[n_time_stats * i + 3] - mean_outtime) *
	(all_time_stats[n_time_stats * i + 3] - mean_outtime);

    }
    var_npart /= nproc;
    var_nneigh /= nproc;
    var_nseed /= nproc;
    var_nptsend /= nproc;
    var_nstep /= nproc;
    var_iotime /= nproc;
    var_commtime /= nproc;
    var_comptime /= nproc;
    var_outtime /= nproc;

    // standard deviations
    std_npart = sqrt(var_npart);
    std_nneigh = sqrt(var_nneigh);
    std_nseed = sqrt(var_nseed);
    std_nptsend = sqrt(var_nptsend);
    std_nstep = sqrt(var_nstep);
    std_iotime = sqrt(var_iotime);
    std_commtime = sqrt(var_commtime);
    std_comptime = sqrt(var_comptime);
    std_outtime = sqrt(var_outtime);

    // misc: data size and aggregate bandwidth
    TotCells = size[0] * size[1] * size[2] / 1.0e6;
    TotDataSize = size[0] * size[1] * size[2] * 12 / 1048576;

    // print results
    fprintf(stderr, "------------------------- Performance Summary -------------------------\n");
    fprintf(stderr, "   -- Aggregate Values --\n");
    fprintf(stderr, "Number of procs = %d\n", nproc);
    fprintf(stderr, "Total time = %.2lf s\n", TotTime);
    fprintf(stderr, "Total data size = %.3f million cells = %.2f MB\n", TotCells, TotDataSize);
    fprintf(stderr, "Total particles = %.3f thousand\n", TotParticles / 1.0e3);
    fprintf(stderr, "Total advection steps computed = %.3f million\n", tot_nstep / 1.0e6);
    fprintf(stderr, "Aggregate input I/O bandwidth = %.0lf MB/s\n", TotDataSize / mean_iotime);
    fprintf(stderr, "   -- Component Values For All Time Blocks --\n");
    fprintf(stderr, "Input time / proc (s) %6s min [%5d] = %-8.2lf max [%5d] = %-8.2lf avg = %-8.2lf std = %-8.2lf\n", "", p_min_iotime, min_iotime, p_max_iotime, max_iotime, mean_iotime, std_iotime);
    fprintf(stderr, "Comp time / proc (s) %7s min [%5d] = %-8.2lf max [%5d] = %-8.2lf avg = %-8.2lf std = %-8.2lf\n", "", p_min_comptime, min_comptime, p_max_comptime, max_comptime, mean_comptime, std_comptime);
    fprintf(stderr, "Comm time / proc (s) %7s min [%5d] = %-8.2lf max [%5d] = %-8.2lf avg = %-8.2lf std = %-8.2lf\n", "", p_min_commtime, min_commtime, p_max_commtime, max_commtime, mean_commtime, std_commtime);
    fprintf(stderr, "Output time / proc (s) %5s min [%5d] = %-8.2lf max [%5d] = %-8.2lf avg = %-8.2lf std = %-8.2lf\n", "", p_min_outtime, min_outtime, p_max_outtime, max_outtime, mean_outtime, std_outtime);
    fprintf(stderr, "Total pts comp / proc %6s min [%5d] = %-8d max [%5d] = %-8d avg = %-8d std = %-8.0f\n", "", p_min_nseed, min_nseed, p_max_nseed, max_nseed, mean_nseed, std_nseed);
    fprintf(stderr, "Total steps comp / proc %4s min [%5d] = %-8d max [%5d] = %-8d avg = %-8d std = %-8.0f\n", "", p_min_nstep, min_nstep, p_max_nstep, max_nstep, mean_nstep, std_nstep);
    fprintf(stderr, "Total pts sent / proc %6s min [%5d] = %-8d max [%5d] = %-8d avg = %-8d std = %-8.0f\n", "", p_min_nptsend, min_nptsend, p_max_nptsend, max_nptsend, mean_nptsend, std_nptsend);
    fprintf(stderr, "   -- Component Values For Final Time Block --\n");
    fprintf(stderr, "Blocks / proc %14s min = %-8d max = %-8d avg = %-8d std = %-8.0f\n", "", min_npart, max_npart, mean_npart, std_npart);
    fprintf(stderr, "Neighbors / block %10s min = %-8d max = %-8d avg = %-8d std = %-8.0f\n", "", min_nneigh, max_nneigh, mean_nneigh, std_nneigh);
    fprintf(stderr, "-----------------------------------------------------------------------\n");

  } // rank = 0

#ifdef USE_IOL
  IOL_Timing_print();
#endif

}
//-----------------------------------------------------------------------
